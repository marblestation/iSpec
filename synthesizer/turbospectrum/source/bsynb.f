      SUBROUTINE BSYNB(NALLIN)
*
*-----------------------------------------------------------------------
*
* BSYNB is merely a continuation of BSYN, data transfered
* via scratch-file 14
*
* B takes line-absorption coefficients generated by A and
* calculates the spectra.
*
* Export version  1988-03-24  ********* Olof Morell *** Uppsala
*
*-----------------------------------------------------------------------
*
      use cubint_module

      include 'spectrum.inc'
*
      parameter (imax=1000)
*
      real pos(imax),intens(imax),mum 
      character*50 mcode
      real prof,xc(ndp)
      real fun(nrays),dmu(nrays),der(nrays)
      doubleprecision xl1,xl2
      doubleprecision del
      common/atmos/ t(ndp),pe(ndp),pg(ndp),xi(ndp),mum(ndp),ro(ndp),
     & nnntau
*
* Special for spherical
*
      COMMON /CTRAN/X(NDP),S(NDP),BPLAN(NDP),XJ(NDP),HFLUX(NDP),XK(NDP)
     & ,FJ(NDP),SOURCE(NDP),TAUS(NDP),DTAUS(NDP),JTAU0,JTAU1,ISCAT
      COMMON /TAUC/TAU(NDP),DTAULN(NDP),NTAU   
      COMMON /ROSSC/ROSS(NDP),CDUMM(NDP) 
      COMMON /RHOC/RHO(NDP)
      COMMON /CSPHER/NCORE,DIFLOG,RADIUS,RR(NDP)
      COMMON /CSTYR/MIHAL  /CTAUM/TAUM
      COMMON /SPACE2/ SPACEDUM1(NDP*7+NDP*NRAYS*5+NRAYS),
     &                nimpac,kimpac(nrays),pimpac(nrays),
     &                MMU(NDP),SPACEDUM2(NDP*2),PFEAU(NRAYS,NDP),
     &                XMU(NRAYS,NDP)
      COMMON /TRDBUG/IDEBUG
      common /limbdk/ pos,intens,totintens,tottrans
      logical debug,extrap
      real fluxme
      dimension y1c(nrays),xmuc(nrays)
      dimension fcfc(lpoint),xlm(lpoint),jlcont(lpoint)
      real sx(5000),slambda(5000),xshifted(2*ndp)
*
      COMMON/CSURF/ HSURF,Y1(NRAYS)
CCC      COMMON/CANGLE/ NMY,XMY(6),XMY2(6),WMY(6)
      COMMON/PIECES/ XL1,XL2,DEL,EPS,NMX,NLBLDU,IINT,XMYC,IWEAK
*
* extension for large number of wavelengths and lines (monster II)
      doubleprecision xlambda
      common/large/ xlambda(lpoint),maxlam,ABSO(NDP,lpoint),
     & absos(ndp,lpoint),absocont(ndp,lpoint),absoscont(ndp,lpoint)
*
      character*256 filterfil
      character*80 filttitle
      logical limbdark,first,findtau1
      common/filter/limbdark,ifilt,filtlam(1000),filttrans(1000),
     &              filterfil,filttitle
      logical hydrovelo
      real velocity
      common/velo/velocity(ndp),hydrovelo,computeIplus

      real taulambda(2*ndp),Iplus(2*ndp),dtaulambda(2*ndp)
      real bigsource(2*ndp)
      logical computeIplus,optthin
*
      real muout(10),isurf(10,lpoint),icsurf(10,lpoint),yout(10)
      real costheta(nrays),uin(nrays)
      integer iout(10)
* muout are mu-point for output intensities, icsurf is for continuum intensity 
*  and isurf for absolute intensity
      character*4 iblnk
      DATA IBLNK/'    '/,profold/0./,first/.true./
      data debug/.false./
      data muout /-1.0, -0.9,-0.8,-0.7,-0.6,-0.5,-0.4,-0.3,-0.2,-0.1/


      PI=3.141593
*
* Initiate mode of calculation
* IINT =1  : intensity at all mu-points / output spectrum is flux spectrum!
*             intensities at all angles are stored in a separate file !
*       Version 7/02-2019 BPz: for intensity, we save intensities at 10 mu angles
*                              in the flux file. Mu=0.1 to 1.0 with step 0.1
* IINT =0  : flux
* XL1      : wavelength where synthetic spectrum starts
* XL2      : wavelength where synthetic spectrum stops
* DEL      : wavelength step
* iweak not used anymore! 
******** IWEAK =1 : weak line approximation for L/KAPPA le. EPS
* note  XL2.gt.XL1

      findtau1=.false.

      if (hydrovelo) then
        findtau1=.true.
* normalize velocity to speed of light
        do k=1,ntau
          velocity(k)=velocity(k)/2.99792458d10
        enddo
      endif
*
      if(iint.eq.0) write(6,201) xl1,xl2,del
ccc      if(iweak.gt.0) write(7,202) eps
*
* Continuum calculations:
*
* 07/02-2019 BPz. We now compute continuum at all wavelengths
* a little more costly in time, but avoid interpolation in wavelength 
* continuum flux, and allows to save continuum intensity at various angles.
* 
      do j=1,maxlam
        do k=1,ntau
          x(k)=absocont(k,j)
          s(k)=absoscont(k,j)
          xlsingle=xlambda(j)
          bplan(k)=bpl(T(k),xlsingle)
        enddo
        if (debug) then
          print*,'bsynb: calling traneq for continuum',j,xlsingle
          do k=1,ntau,5
            print*,(x(kk),s(kk),kk=k,k+4)
          enddo
        endif
        call traneq
*
* calculate emergent continuum intensity at prescribed mu-points
*
        do k=1,mmu(1)
          costheta(k)=xmu(k,1)
        enddo
        call cubintp14(y1,costheta,uin,muout,yout,iout,mmu(1),
     &                 10,3,0,0,0,
     &                     extrap)
        do k=1,10
          icsurf(k,j)=yout(k)
        enddo
*
* Spherical continuum fluxes
*
C FLUX TO PRINT
        hflux1c=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1c=amax1(1e-30,hflux1c)
        hflux2c=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
        fcfc(j)=hflux1c

C        GFLUX1C=HFLUX1/PI*XLambda(J)**2/CLIGHT
C        GFLUX2C=HFLUX2/PI*XLambda(J)**2/CLIGHT
C        FFLUX1C=-2.5*ALOG10(AMAX1(GFLUX1,1E-20))
C        FFLUX2C=-2.5*ALOG10(AMAX1(GFLUX2,1E-20))
C
*
* End of continuum spherical fluxes
*
        if (debug) print*,j,xlsingle,fcfc(j)
      enddo
*
* Start loop over wavelengths with lines
*
      numb=0
      do j=1,maxlam
        do k=1,ntau
          x(k)=abso(k,j)
          s(k)=absos(k,j)
          xlsingle=xlambda(j)
          bplan(k)=bpl(T(k),xlsingle)
        enddo
        call traneq
*
* calculate emergent intensity
*
        
* save traneq's fluxes
        hflux1tr=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1tr=amax1(1e-30,hflux1tr)

        if (computeIplus) then
*
************************************************************************
* Compute Iplus, for all rays, at this wavelength. BPz 08/08-2001
* calculate taulambda along the ray
          do i=1,nimpac
            ntaui=kimpac(i)
            zold=0.0
            if (hydrovelo) then
*
* This is only experimental.
* we compute the emergent intensities with a velocity field.
* We shift only the kappas. The source function is taken as 
* that in the static case. the scattering part of the opacity 
* is not shifted, to save computing time.                 
* velocity (in cm/s) in model should be positive outwards.
* If xlb_vshifted is the wavelength in the observer's frame at which
* the line position is shifted [(lambda_0-lambda)/lambda_0=v/c],
* xlb_vshifted=xlb*lshift, with lshift(k)=1.d0-velocity/c
* (Here Velocity contains velocity/c_light, and shift=1-velocity)
*
              do k=1,ntaui
                shiftmax=(-velocity(k))*xlsingle
* avoid n=0 for small shiftmax (+2)
                n=(int(abs(shiftmax)/del)+2)
                jmin=max(j-n,1)
                jmax=min(j+n,maxlam)
                n=jmax-jmin+1
                if (n.gt.5000) then
                  print*,'velocity shift is too large!'
                  print*,'shift =',shift,' n=',n
                  print*,'increase dimension !'
                  stop 'bsynb'
                endif
                do is=1,n
* slambda is of the order of 1, to minimize computation errors due to single precision.
* but we cannot shift outside the computation interval. Therefore the spectrum will
* be wrong at the beginning and end of computed range.
                  iposition=jmin+is-1
                  slambda(is)=sngl(xlambda(iposition)-xlambda(j))
                  sx(is)=abso(k,iposition)
                enddo
                shift=shiftmax*xmu(i,k)
cc                print*,' c tint', shift,n,slambda(1),slambda(n)
                call tint(n,slambda,sx,shift,xshifted(k))
* now do the back side of the shell (mirror velocity)
                shift=-shift
                call tint(n,slambda,sx,shift,xshifted(2*ntaui-k))
              enddo
            else
              do k=1,ntaui
                xshifted(k)=x(k)
                xshifted(2*ntaui-k)=x(k)
              enddo
            endif
CCC CONTINUE FROM HERE FOR BACKSDIDE !!!!!!
** n -> gives call tint(2*n, x,y,xint,yint) !! attention a la single precision !!
** puis caluler les kappas pour chaque v/c*cos(theta), avec a chaque fois l'array
** lambda (2*n), kappa(2*n) centre sur le lambda.

            if (i.gt.ncore) then
C rays that cross the atmosphere
              optthin=.true.
            else
C rays that stop at some deepest depth (the core)
              optthin=.false.
            endif

            do k=1,ntaui
              z=sqrt(rr(k)**2-pimpac(i)**2)
              bigsource(k)=source(k)
              if (k.gt.1) then
                dz=z-zold
                dzdr=dz/(rr(k)-rr(k-1))
                dtaulambda(k)=dzdr*0.5*
     &                       (xshifted(k)+s(k)+
     &                       xshifted(k-1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                if (optthin) then
c compute optical thickness for the symmetric part of the ray on the backside
                  index=2*ntaui+1-k
                  dtaulambda(index)=dzdr*0.5*
     &                     (xshifted(index)+s(k)+
     &                     xshifted(index+1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                  bigsource(index)=source(k-1)
cc                print*,'bsynb, taul',dtaulambda(k),dtaulambda(index)
                endif
              endif
              zold=z
            enddo
            taulambda(1)=(x(1)+s(1))*tau(1)/
     &                    sqrt(1.-(pimpac(i)/rr(1))**2)
            do k=2,ntaui
              taulambda(k)=taulambda(k-1)+dtaulambda(k)
            enddo
            ntauicall=ntaui
            if (optthin) then
              do k=ntaui+1,2*ntaui-1
                taulambda(k)=taulambda(k-1)+dtaulambda(k)
              enddo
              ntauicall=2*ntaui-1
            endif
            call Iplus_calc(ntauicall,taulambda,bigsource,Iplus,optthin)
            surfIplus=Iplus(1)*exp(-taulambda(1))+
     &           bigsource(1)*(1.-exp(-taulambda(1)))**2
cc              print*,'Pfeau(1,1) ',pfeau(1,1)
************************************************************************
            if (xlsingle.gt.7800..and.xlsingle.lt.7800.3) then
              if (i.eq.1) then
                print*,'bsynb; lambda=',xlsingle,' Iplus(Source):'
              endif
              do k=ntauicall,1,-1
                print*,k,taulambda(k),bigsource(k),Iplus(k)
              enddo
              if (optthin) then
                print*,'mu ',xmu(i,1),'Y1 ',y1(i),' Isurf ',
     &              surfIplus,'Thin'
              else
                print*,'mu ',xmu(i,1),'Y1 ',y1(i),' Isurf ',
     &              surfIplus,'Thick'
              endif
            endif
************************************************************************
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
            if (xmu(i,1).eq.-1.0) surfIsave=surfIplus
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
*
* Replace Y1 by surfIplus, to prepare integration of flux
            Y1(i)=surfIplus
*
* End of the ray loop
          enddo
          if (hydrovelo) then
* we compute the emergent flux at this lambda
            NMU=MMU(1)
            PX=-XMU(NMU-2,1)/(XMU(NMU-1,1)-XMU(NMU-2,1))
            QX=1.-PX
            Y1(NMU)=EXP(ALOG(Y1(NMU-2))*QX+ALOG(Y1(NMU-1))*PX)
            DO I=1,NMU
              FUN(I)=-XMU(I,1)*Y1(I)
            ENDDO
            HSURF=0.5*TRQUA2(NMU,XMU,FUN,DMU,DER)
          endif
        endif
************************************************************************
*
* calculate emergent line intensity at prescribed mu-points
*
        do k=1,mmu(1)
          costheta(k)=xmu(k,1)
        enddo
        call cubintp14(y1,costheta,uin,muout,yout,iout,mmu(1),
     &                     10,3,0,0,0,
     &                     extrap)
        do k=1,10
          isurf(k,j)=yout(k)
        enddo
*
* Spherical fluxes
*
C FLUX TO PRINT
C renormalize to standard radius at tauross=1
        hflux1=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1=amax1(1e-30,hflux1)
        hflux2=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
*        fluxme=hflux1/pi
        fluxme=hflux1

* divide by continuum flux
        prf=fluxme/fcfc(j)

        if (debug) print*,j,xlsingle,fluxme,prf
*
* End of spherical fluxes
*
        prof=1.-prf
*
* find depth where tau_lambda=1

        if (findtau1) then
          taulambda(1)=tau(1)*(x(1)+s(1))
          print*,'lambda k tau tau_lambda Temp density radius R(tau=1)'
          do k=2,ntau
            taulambda(k)=taulambda(k-1)+(tau(k)-tau(k-1))*(x(k)+s(k)+
     &                   x(k-1)+s(k-1))*0.5
            if (taulambda(k).ge.1.) then
               print333,xlambda(j),k,tau(k),taulambda(k),t(k),ro(k),
     &                  rr(k),radius
333         format('radius at tau=1',f10.3,1x,i3,1x,1pe11.4,1x,
     &                1pe11.4,1x,0pf7.1,1x,
     &                1pe11.4,2(1x,1pe12.5),0p)
               goto 1966
            endif
          enddo
1966      continue
        endif
*
cc        if (limbdark) then
cc          if (xlambda(j).ge.xl1.and.xlambda(j).le.xl2) then
cc            sdel=del
cc            call weightlimb(xlsingle,sdel)
cc          endif
cc        endif
*
* store spectrum in x,y format
* integral_inf^+inf (fluxme) = sigma Teff^4

        if (iint.eq.0) then
          if (computeIplus) then
c We should have surface flux here!
* lambda, normalized and absolute flux from source function summation, absolute feautrier flux, 
* central intensity from summmed source function
            write(46,2018) xlambda(j),prf,fluxme,hflux1tr,surfIsave
          else
* lambda, normalized feautrier flux, absolute feautrier flux
            write(46,1965) xlambda(j),prf,fluxme
1964        format(f11.3,1x,f10.5,1x,1pe12.5)
          endif
        else if (iint.gt.0) then
          if (computeIplus) then
* We store additional columns for the intensity at mu=1.0 to 0.1, step 0.1.
* So we have: lambda, normalized and absolute flux for summed source function,
* absolute Feautrier flux, and intensities for summed source function:
* , normalized intensity at mu=1.0, intensity at mu=1.0,
* and then Inorm, I for mu=0.9, 0.8, ..., 0.1.
            write(46,1967) xlambda(j),prf,fluxme,hflux1tr,
     &                    (isurf(k,j),isurf(k,j)/icsurf(k,j),k=1,10)
1967        format(f11.3,1x,f10.5,1x,1pe12.5,1x,1pe12.5,2x,
     &             10(1x,1pe12.5,1x,0pf10.5))
          else
* We store additional columns for the intensity at mu=1.0 to 0.1, step 0.1.
* So we have: lambda, normalized flux, flux, normalized intensity at mu=1.0, intensity at mu=1.0,
* and then Inorm, I for mu=0.9, 0.8, ..., 0.1.
            write(46,1965) xlambda(j),prf,fluxme,
     &                    (isurf(k,j),isurf(k,j)/icsurf(k,j),k=1,10)
1965        format(f11.3,1x,f10.5,1x,1pe12.5,2x,
     &             10(1x,1pe12.5,1x,0pf10.5))
cc            write(46,1965) xlambda(j),prf,fluxme,y1(1)
2018        format(f11.3,1x,f10.5,1x,1pe12.5,1x,e12.5,1x,e12.5)
          endif
        endif

*
* End of wavelength loop
      enddo
*
      call clock
      RETURN
*
  100 FORMAT(4X,I1,6X,I3)
  207 FORMAT(' SPECTRUM CALCULATED FOR THE FOLLOWING ',I3,' LINES'
     &      /' ELEMENT LAMBDA XI(EV) LOG(GF) LOG(ABUND) LINE NO')
  208 FORMAT('   ',A2,I2,F9.2,F5.2,1X,F6.2,3X,F7.2,4X,I5)
  200 FORMAT(' INTENSITY SPECTRUM AT MU=',F6.2,' BETWEEN',F10.3,
     &      ' AND',F10.3,' A WITH STEP',F6.3,' A')
  201 FORMAT(' FLUX SPECTRUM BETWEEN',F10.3,' A AND ',F10.3,' A WITH',
     &       ' STEP',F6.3,' A')
  202 FORMAT(' ***WEAK LINE APPROX FOR L/KAPPA L.T.',F7.4)
  203 FORMAT(' MODEL ATMOSPHERE:',A)
  204 FORMAT(' CONTINUUM FLUX=',E12.4, ' AT ',f10.2,'AA')
  205 FORMAT(' CONTINUUM INTENSITY=',E12.4)
  206 FORMAT(1X,10F8.4)
*
      END
