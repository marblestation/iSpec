      SUBROUTINE BSYNB(nangles,muoutp)
*
*-----------------------------------------------------------------------
*
* BSYNB is merely a continuation of BSYN, data transfered
* via scratch-file 14
*
* B takes line-absorption coefficients generated by A and
* calculates the spectra.
*
* Export version  1988-03-24  ********* Olof Morell *** Uppsala
*
*-----------------------------------------------------------------------
*
      use cubint_module

      include 'spectrum.inc'
*
      parameter (imax=1000)
*
      real pos(imax),intens(imax),mum 
      character*50 mcode
      real prof,xc(ndp)
      real fun(nrays),dmu(nrays),der(nrays)
      doubleprecision xl1,xl2
      doubleprecision del
      common/atmos/ t(ndp),pe(ndp),pg(ndp),xi(ndp),mum(ndp),ro(ndp),
     & nnntau
*
* Special for spherical
*
      COMMON /CTRAN/X(NDP),S(NDP),BPLAN(NDP),XJ(NDP),HFLUX(NDP),XK(NDP)
     & ,FJ(NDP),SOURCE(NDP),TAUS(NDP),DTAUS(NDP),JTAU0,JTAU1,ISCAT
      COMMON /TAUC/TAU(NDP),DTAULN(NDP),NTAU   
      COMMON /ROSSC/ROSS(NDP),CDUMM(NDP) 
      COMMON /RHOC/RHO(NDP)
      COMMON /CSPHER/NCORE,DIFLOG,RADIUS,RR(NDP)
      COMMON /CSTYR/MIHAL  /CTAUM/TAUM
! taut is the monochromatic optical depth, computed in traneq/trrays
      COMMON /SPACE2/ SPACEDUM1(NDP*7+NDP*NRAYS*5+NRAYS),
     &                nimpac,kimpac(nrays),pimpac(nrays),
     &                MMU(NDP),taut(ndp),dtaut(ndp),PFEAU(NRAYS,NDP),
     &                XMU(NRAYS,NDP)
      COMMON /TRDBUG/IDEBUG
      common /limbdk/ pos,intens,totintens,tottrans
      logical debug,write_radius
      real fluxme
      dimension y1c(nrays),xmuc(nrays)
      dimension fcfc(lpoint),xlm(lpoint),jlcont(lpoint)
      real sx(5000),slambda(5000),xshifted(2*ndp)
*
      COMMON/CSURF/ HSURF,Y1(NRAYS)
      COMMON/PIECES/ XL1,XL2,DEL,EPS,NMX,NLBLDU,IINT,XMYC,IWEAK
*
* extension for large number of wavelengths and lines (monster II)
      doubleprecision xlambda
      doubleprecision source_function
      common/large/ xlambda(lpoint),source_function(ndp,lpoint),
     & maxlam,ABSO(NDP,lpoint),
     & absos(ndp,lpoint),absocont(ndp,lpoint),absoscont(ndp,lpoint)
*
      character*256 filterfil
      character*80 filttitle
      logical limbdark,first,findtau1
      common/filter/limbdark,ifilt,filtlam(1000),filttrans(1000),
     &              filterfil,filttitle
      logical hydrovelo
      real velocity
      common/velo/velocity(ndp),hydrovelo,computeIplus

* special version NLTE
      real dzdr2,mex
      integer kmax
      logical nlte
      common /nlte_common/ nlte

      real taulambda(2*ndp),Iplus(2*ndp),dtaulambda(2*ndp)
      real bigsource(2*ndp)
      logical computeIplus,optthin
*
      real costheta(nrays)
*
      character*4 iblnk
      DATA IBLNK/'    '/,profold/0./,first/.true./
      data debug/.false./
      data write_radius/.true./

* icsurf is for continuum intensity and isurf for absolute intensity
* muoutp are mu-points for output intensities
* Use 12 Gauss-Radau points by default, if nangles < 0,
* Otherwise use nangles mu-points from input
*
      logical extrap
      integer nangles
      integer iout(nangles)
      real muout(nangles),yout(nangles),uin(nrays),muoutp(nangles)
      real, allocatable :: isurf(:,:),icsurf(:,:)
!
! in spherical case, cos(theta) must be <0. muoutp are the cos(theta) for the PP case.
      do i=1,nangles
        muout(i)=-muoutp(nangles+1-i)
      enddo

      allocate(isurf(nangles,lpoint))
      allocate(icsurf(nangles,lpoint))

      PI=4.*atan(1.)
! 3.141593
*
* Initiate mode of calculation
* IINT =1  : intensity at all mu-points / output spectrum is flux spectrum!
*             intensities at all angles are stored in a separate file !
* IINT =0  : flux
* XL1      : wavelength where synthetic spectrum starts
* XL2      : wavelength where synthetic spectrum stops
* DEL      : wavelength step
* iweak not used anymore! 
******** IWEAK =1 : weak line approximation for L/KAPPA le. EPS
* note  XL2.gt.XL1

      findtau1=.false.

      if (hydrovelo) then
        findtau1=.true.
* normalize velocity to speed of light
        do k=1,ntau
          velocity(k)=velocity(k)/2.99792458d10
        enddo
      endif
*
      if(iint.eq.0) write(6,201) xl1,xl2,del
ccc      if(iweak.gt.0) write(7,202) eps
*
* Continuum calculations:
*
* 07/02-2019 BPz. We now compute continuum at all wavelengths
* a little more costly in time, but avoid interpolation in wavelength 
* continuum flux, and allows to save continuum intensity at various angles.
* 
      do j=1,maxlam
        xlsingle=xlambda(j)
        do k=1,ntau
          x(k)=absocont(k,j)
          s(k)=absoscont(k,j)
*
* NLTE case implemented for continuum
*
          if (nlte) then
! test            bplan(k)=source_function(k,j)
* Using the Planck function is OK if we don't have NLTE for the species contributing to the continuum.
*
            bplan(k)=bpl(T(k),xlsingle)
          else
            bplan(k)=bpl(T(k),xlsingle)
          endif
*
        enddo
        if (debug) then
          print*,'bsynb: calling traneq for continuum',j,xlsingle
          do k=1,ntau,5
            print*,(x(kk),s(kk),kk=k,k+4)
          enddo
        endif
!
! in traneq, the source function is iterated to get the scattering part as well: S=(kB+sJ)/(k+s)
!
        call traneq
!
        if (idebug.gt.1) then
! this wavelngth gave non-positive result. We flag it with a negative flux ! BPz 6-Apr-2021
          print*,'lambda = ',xlsingle,' skipped'
          hsurf=-1.0
        endif
!
* save traneq continuum flux
        hflux1ctr=4.*pi*hsurf*(rr(1)/radius)**2
        if (hflux1ctr.ge.0.) hflux1ctr=amax1(1e-30,hflux1ctr)
*
*
* PRINT OUT lambda number 10
*
!        if (j.eq.10) then
!          do k=1,mmu(1)
!            write(97,*) xmu(k,1),y1(k),'traneq'
!          enddo
!        endif
!
        if (computeIplus) then
*
************************************************************************
* Compute Iplus, for all rays, at this wavelength.
* calculate taulambda along the ray
          do i=1,nimpac
            ntaui=kimpac(i)
            zold=0.0
* here we could implement a shift of the opacities if wanted
            do k=1,ntaui
              xshifted(k)=x(k)
              xshifted(2*ntaui-k)=x(k)
            enddo

            if (i.gt.ncore) then
C rays that cross the atmosphere
              optthin=.true.
            else
C rays that stop at some deepest depth (the core)
              optthin=.false.
            endif

            do k=1,ntaui
              z=sqrt(rr(k)**2-pimpac(i)**2)
              bigsource(k)=source(k)
              if (k.gt.1) then
                dz=z-zold
                dzdr=dz/(rr(k)-rr(k-1))
                if (k.eq.2) dzdr2=dzdr
                dtaulambda(k)=dzdr*0.5*
     &                       (xshifted(k)+s(k)+
     &                       xshifted(k-1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                if (optthin) then
c compute optical thickness for the symmetric part of the ray on the backside
                  index=2*ntaui+1-k
                  dtaulambda(index)=dzdr*0.5*
     &                     (xshifted(index)+s(k)+
     &                     xshifted(index-1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                  bigsource(index)=source(k-1)
cc                print*,'bsynb, taul',dtaulambda(k),dtaulambda(index)
                endif
              endif
              zold=z
            enddo
            taulambda(1)=(xshifted(1)+s(1))*tau(1)*dzdr2
            do k=2,ntaui
              taulambda(k)=taulambda(k-1)+dtaulambda(k)
            enddo
            ntauicall=ntaui
            if (optthin) then
              do k=ntaui+1,2*ntaui-1
                taulambda(k)=taulambda(k-1)+dtaulambda(k)
!                if (taulambda(k).ge.
!     &              taum*sqrt((xshifted(k)+s(k))/xshifted(k))) then
!                  optthin=.false.
!                  kmax=k
!                  print*,'not thin',kmax,2*ntaui-1,taulambda(k)
!                  exit
!                endif
! TAU < TAUM*SQRT((X+S)/X)
              enddo
              if (.not.optthin) then
                ntauicall=kmax
              else
                ntauicall=2*ntaui-1
              endif
            endif
            call Iplus_calc(ntauicall,taulambda,bigsource,Iplus,optthin)
            mex=taulambda(1)*(1.-taulambda(1)/2.*(1.-taulambda(1)/3.*
     &            (1.-taulambda(1)/4.)))
            if (taulambda(1).gt.0.01) mex=1.-exp(-taulambda(1))
            surfIplus=Iplus(1)+
     &           (bigsource(1)-Iplus(1))*mex
*
* Replace Y1 by surfIplus, to prepare integration of flux
            write(96,*) y1(i),surfiplus/y1(i),taulambda(ntauicall)
            Y1(i)=surfIplus

            if (j.eq.10) then
              do k=1,ntauicall
                write(95,*) xmu(i,1),taulambda(k),bigsource(k)
              enddo
            endif

*
* End of the ray loop
          enddo
* we compute the emergent flux at this lambda for the Ipluscalc case
          NMU=MMU(1)
          PX=-XMU(NMU-2,1)/(XMU(NMU-1,1)-XMU(NMU-2,1))
          QX=1.-PX
          Y1(NMU)=EXP(ALOG(Y1(NMU-2))*QX+ALOG(Y1(NMU-1))*PX)
          DO I=1,NMU
            FUN(I)=-XMU(I,1)*Y1(I)
          ENDDO
          HSURF=0.5*TRQUA2(NMU,XMU,FUN,DMU,DER)
*
* PRINT OUT lambda number 10
*
!          if (j.eq.10) then
!            do k=1,mmu(1)
!             write(97,*) xmu(k,1),y1(k),'Ipluscalc'
!            enddo
!          endif

        endif
************************************************************************
*
* calculate emergent continuum intensity at prescribed mu-points
*
! This sampling is not so good at the limb. One should have more points
! at the limb. Maybe some even spacing in log(mu), e.g. 0 -0.2 -0.4 -0.6 -0.8 -1.0 -1.25 -1.50 -1.75 -2.0 ?
!
        do k=1,mmu(1)
          costheta(k)=xmu(k,1)
        enddo
        call cubintp14(y1,costheta,uin,muout,yout,iout,mmu(1),
     &                 nangles,3,0,0,0,
     &                     extrap)
        do k=1,nangles
          icsurf(k,j)=yout(k)
        enddo
!*
!* PRINT OUT lambda number 10
!*
!        if (j.eq.10) then
!          do k=1,10
!            write(97,*) muout(k),icsurf(k,j)
!          enddo
!        endif

*
* Spherical continuum fluxes (from Ipluscalc if computeIplus = .true., else from traneq)
*
C FLUX TO PRINT
        hflux1c=4.*pi*hsurf*(rr(1)/radius)**2
        hflux1c=amax1(1e-30,hflux1c)
        hflux2c=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
        fcfc(j)=hflux1c

C        GFLUX1C=HFLUX1/PI*XLambda(J)**2/CLIGHT
C        GFLUX2C=HFLUX2/PI*XLambda(J)**2/CLIGHT
C        FFLUX1C=-2.5*ALOG10(AMAX1(GFLUX1,1E-20))
C        FFLUX2C=-2.5*ALOG10(AMAX1(GFLUX2,1E-20))
C
*
* End of continuum spherical fluxes
*
        if (debug) print*,j,xlsingle,fcfc(j)
      enddo
*
* Start loop over wavelengths with lines
*
      numb=0
      if (write_radius) then
! used for optical depth check
        open(99, file='radius_tau1.txt')
        write(99,998)
998     format('lambda, k, taulambda, tauross, T, r/radius')
      endif
!
! write header in spectrum file, for the intensity case.
!
      if (iint.gt.0) then
        write(46,1111) (-muout(j),j=nangles,1,-1)
1111    format ('# mu-points ',30(1x,1pe13.6))
      endif
 
      do j=1,maxlam
        xlsingle=xlambda(j)
        do k=1,ntau
! the continuum opacity is not included in abso

          x(k)=abso(k,j)+absocont(k,j)
          s(k)=absos(k,j)+absoscont(k,j)
*
* NLTE case implemented for lines
*
          if (nlte) then
!            bplan(k)=source_function(k,j)
            bplan(k)=(source_function(k,j)*abso(k,j)+
     &                 bpl(T(k),xlsingle)*absocont(k,j))/x(k)
          else
            bplan(k)=bpl(T(k),xlsingle)
          endif
* 
        enddo
!
! source function is iterated in traneq to get S=(kB+sJ)/(k+s). 
!
        call traneq
!
        if (idebug.gt.1) then
! this wavelngth gave non-positive result. We flag it with a negative flux ! BPz 6-Apr-2021
          print*,'lambda = ',xlsingle,' skipped'
          hsurf=-1.0
        endif
!
!
! check optical depth unity and print out
        if (write_radius) then
          do k=1,ntau
            if (taut(k).ge.1.0) then
!
!
!
            write(99,999) xlsingle,k,taut(k),tau(k),T(k),rr(k)/radius
999         format(f11.3,1x,i3,1x,1pe12.5,1x,1pe12.5,1x,0pf8.1,1x,f8.4)
!
!
!
            exit
            endif
          enddo
        endif
*
* calculate emergent intensity
*
        
* save traneq's fluxes
        hflux1tr=4.*pi*hsurf*(rr(1)/radius)**2
        if (hflux1tr.ge.0.) hflux1tr=amax1(1e-30,hflux1tr)
!*
!* PRINT OUT lambda number 10
!*
!        if (j.eq.10) then
!          do k=1,mmu(1)
!            write(111,*) xmu(k,1),y1(k),'traneq'
!          enddo
!        endif

        if (computeIplus) then
*
************************************************************************
* Compute Iplus, for all rays, at this wavelength. BPz 08/08-2001
* calculate taulambda along the ray
          do i=1,nimpac
            ntaui=kimpac(i)
            zold=0.0
            if (hydrovelo) then
*
* This is only experimental.
* we compute the emergent intensities with a velocity field.
* We shift only the kappas. The source function is taken as 
* that in the static case. the scattering part of the opacity 
* is not shifted, to save computing time.                 
* velocity (in cm/s) in model should be positive outwards.
* If xlb_vshifted is the wavelength in the observer's frame at which
* the line position is shifted [(lambda_0-lambda)/lambda_0=v/c],
* xlb_vshifted=xlb*lshift, with lshift(k)=1.d0-velocity/c
* (Here Velocity contains velocity/c_light, and shift=1-velocity)
*
              do k=1,ntaui
                shiftmax=(-velocity(k))*xlsingle
* avoid n=0 for small shiftmax (+2)
                n=(int(abs(shiftmax)/del)+2)
                jmin=max(j-n,1)
                jmax=min(j+n,maxlam)
                n=jmax-jmin+1
                if (n.gt.5000) then
                  print*,'velocity shift is too large!'
                  print*,'shift =',shift,' n=',n
                  print*,'increase dimension !'
                  stop 'bsynb'
                endif
                do is=1,n
* slambda is of the order of 1, to minimize computation errors due to single precision.
* but we cannot shift outside the computation interval. Therefore the spectrum will
* be wrong at the beginning and end of computed range.
                  iposition=jmin+is-1
                  slambda(is)=sngl(xlambda(iposition)-xlambda(j))
                  sx(is)=abso(k,iposition)
                enddo
                shift=shiftmax*xmu(i,k)
cc                print*,' c tint', shift,n,slambda(1),slambda(n)
                call tint(n,slambda,sx,shift,xshifted(k))
* now do the back side of the shell (mirror velocity)
                shift=-shift
                call tint(n,slambda,sx,shift,xshifted(2*ntaui-k))
              enddo
            else
              do k=1,ntaui
                xshifted(k)=x(k)
                xshifted(2*ntaui-k)=x(k)
              enddo
            endif

            if (i.gt.ncore) then
C rays that cross the atmosphere
              optthin=.true.
            else
C rays that stop at some deepest depth (the core)
              optthin=.false.
            endif

            do k=1,ntaui
              z=sqrt(rr(k)**2-pimpac(i)**2)
              bigsource(k)=source(k)
              if (k.gt.1) then
                dz=z-zold
                dzdr=dz/(rr(k)-rr(k-1))
                if (k.eq.2) dzdr2=dzdr
                dtaulambda(k)=dzdr*0.5*
     &                       (xshifted(k)+s(k)+
     &                       xshifted(k-1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                if (optthin) then
c compute optical thickness for the symmetric part of the ray on the backside
                  index=2*ntaui+1-k
                  dtaulambda(index)=dzdr*0.5*
     &                     (xshifted(index)+s(k)+
     &                     xshifted(index-1)+s(k-1))*            ! corrected on 31/03-2020. Was : xshifted(index+1)+s(k-1))*
     &                     (tau(k)-tau(k-1))
                  bigsource(index)=source(k-1)
cc                print*,'bsynb, taul',dtaulambda(k),dtaulambda(index)
                endif
              endif
              zold=z
            enddo
cc            taulambda(1)=(xshifted(1)+s(1))*tau(1)/              ! corrected on 1/04-202. Was : x(1)
cc     &                    sqrt(1.-(pimpac(i)/rr(1))**2)
            taulambda(1)=(xshifted(1)+s(1))*tau(1)*dzdr2         ! corrected on 1/04/2020 to agree with tranfr.f
            do k=2,ntaui
              taulambda(k)=taulambda(k-1)+dtaulambda(k)
            enddo
            ntauicall=ntaui
            if (optthin) then
              do k=ntaui+1,2*ntaui-1
                taulambda(k)=taulambda(k-1)+dtaulambda(k)
!                if (taulambda(k).ge.
!     &              taum*sqrt((xshifted(k)+s(k))/xshifted(k))) then
!                  optthin=.false.
!                  kmax=k
!                  print*,'not thin',kmax,2*ntaui-1,taulambda(k)
!                  exit
!                endif
! TAU < TAUM*SQRT((X+S)/X)
              enddo
              if (.not.optthin) then
                ntauicall=kmax
              else
                ntauicall=2*ntaui-1
              endif
            endif
            call Iplus_calc(ntauicall,taulambda,bigsource,Iplus,optthin)
            mex=taulambda(1)*(1.-taulambda(1)/2.*(1.-taulambda(1)/3.*
     &            (1.-taulambda(1)/4.)))
            if (taulambda(1).gt.0.01) mex=1.-exp(-taulambda(1))
            surfIplus=Iplus(1)+
     &           (bigsource(1)-Iplus(1))*mex
*
cc              print*,'Pfeau(1,1) ',pfeau(1,1)
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
            if (xmu(i,1).eq.-1.0) surfIsave=surfIplus
* TEST !!!! SAVE ONLY I(mu=1) !!!!!!!!!
*
* Replace Y1 by surfIplus, to prepare integration of flux
            write(98,*) y1(i),surfiplus/y1(i),taulambda(ntauicall)

            if (abs(xlambda(j)-23707.55).lt.0.001) then
              do k=1,ntauicall
                write(94,*) xmu(i,1),taulambda(k),bigsource(k)
              enddo
            endif

            Y1(i)=surfIplus
*
* End of the ray loop
          enddo
cccc          if (hydrovelo) then
* we compute the emergent flux at this lambda
            NMU=MMU(1)
            PX=-XMU(NMU-2,1)/(XMU(NMU-1,1)-XMU(NMU-2,1))
            QX=1.-PX
            Y1(NMU)=EXP(ALOG(Y1(NMU-2))*QX+ALOG(Y1(NMU-1))*PX)
            DO I=1,NMU
              FUN(I)=-XMU(I,1)*Y1(I)
            ENDDO
            HSURF=0.5*TRQUA2(NMU,XMU,FUN,DMU,DER)
cccc          endif
        endif
************************************************************************
*
* calculate emergent line intensity at prescribed mu-points
*
!*
!* PRINT OUT one lambda
!*
        if (abs(xlambda(j)-23707.55).lt.0.001) then

!        if (j.eq.10) then
          write(111,'(a)') 'original'
          do k=1,mmu(1)
           write(111,*) xmu(k,1),y1(k)
          enddo
        endif

        do k=1,mmu(1)
          costheta(k)=xmu(k,1)
        enddo
        call cubintp14(y1,costheta,uin,muout,yout,iout,mmu(1),
     &                     nangles,3,0,0,0,
     &                     extrap)
        do k=1,nangles
          isurf(k,j)=yout(k)
        enddo
!*
!* PRINT OUT one lambda
!*
        if (abs(xlambda(j)-23707.55).lt.0.001) then

          write(111,'(a)') 'interpolated'
          do k=1,nangles
            write(111,*) muout(k),isurf(k,j)
          enddo
          write(111,'(a)') 'FLUX at outermost layer'
          write(111,*) hsurf*4.*pi
        endif
!
*
* Spherical fluxes
*
* FLUX TO PRINT (from Ipluscalc if computeIplus = .true., else from traneq)
*
* renormalize to standard radius at tauross=1
        hflux1=4.*pi*hsurf*(rr(1)/radius)**2
        if (hflux1.ge.0.) then hflux1=amax1(1e-30,hflux1)
        hflux2=4.*pi*hflux(ntau)*(rr(ntau)/radius)**2
* starting with version 12.1, flux is not divided by pi anymore. 
* F_lambda integrated over lambda is sigma.Teff^4
*        fluxme=hflux1/pi
        fluxme=hflux1

* divide by continuum flux
        if (fcfc(j).gt.0.) then
          prf=fluxme/fcfc(j)
        else
! flag wavelength that did not converge in traneq ! BPz 6-Apr-2021
          prf=-1.
        endif

        if (debug) print*,j,xlsingle,fluxme,prf
*
* End of spherical fluxes
*
        prof=1.-prf
*
*
* find depth where tau_lambda=1

        if (findtau1) then
          taulambda(1)=tau(1)*(x(1)+s(1))
          print*,'lambda k tau tau_lambda Temp density radius R(tau=1)'
          do k=2,ntau
            taulambda(k)=taulambda(k-1)+(tau(k)-tau(k-1))*(x(k)+s(k)+
     &                   x(k-1)+s(k-1))*0.5
            if (taulambda(k).ge.1.) then
               print333,xlambda(j),k,tau(k),taulambda(k),t(k),ro(k),
     &                  rr(k),radius
333         format('radius at tau=1',f10.3,1x,i3,1x,1pe11.4,1x,
     &                1pe11.4,1x,0pf7.1,1x,
     &                1pe11.4,2(1x,1pe12.5),0p)
               goto 1966
            endif
          enddo
1966      continue
        endif
*
cc        if (limbdark) then
cc          if (xlambda(j).ge.xl1.and.xlambda(j).le.xl2) then
cc            sdel=del
cc            call weightlimb(xlsingle,sdel)
cc          endif
cc        endif
*
* store spectrum in x,y format
* integral_inf^+inf (fluxme) = sigma Teff^4
*
* We now have (depending on computeIplus case activated or not)
* continuum flux :
* from traneq:     hflux1ctr, fluxme
* from Ipluscalc:  hflux1c, fluxme
* continuum intensities at prescribed mu's
* from Ipluscalc:  icsurf(mu,lambda)
*
* line flux :
* from traneq:     hflux1tr, fluxme
* from Ipluscalc:  hflux1, fluxme
* line intensities at prescribed mu's
* from Ipluscalc:  isurf(mu,lambda)
*
        if (iint.eq.0) then
          if (computeIplus) then
c We should have surface flux here!
* lambda, normalized and absolute flux from source function summation, absolute feautrier flux, 
* central intensity from summmed source function
            write(46,2018) xlambda(j),prf,fluxme,hflux1tr,surfIsave
          else
* lambda, normalized feautrier flux, absolute feautrier flux
            write(46,1965) xlambda(j),prf,fluxme
1964        format(f11.3,1x,f10.5,1x,1pe12.5)
          endif
        else if (iint.gt.0) then
          if (computeIplus) then
* We store additional columns for the intensity.
* So we have: lambda, normalized and absolute flux for summed source function,
* absolute Feautrier flux, and intensities for summed source function:
* , intensity at mu=1.0,  normalized intensity at mu=1.0,
* and then I, Inorm for the 12 Gauss-Radau distributed angles
            write(46,1967) xlambda(j),prf,fluxme,hflux1tr,
     &                    (isurf(k,j),isurf(k,j)/icsurf(k,j),
     &                     k=nangles,1,-1)
1967        format(f11.3,1x,f10.5,1x,1pe12.5,1x,1pe12.5,2x,
     &             30(1x,1pe12.5,1x,0pf10.5))
          else
* We store additional columns for the intensity at nangles values of mu
* So we have: lambda, normalized flux, flux, and then intensity and normalised intensity
* for all mu's
* BPz 30-Jan-2025: format changed for normalized intensities to allow large numbers
*                  as this may happen with extended envelopes when lines go in emission

            write(46,1965) xlambda(j),prf,fluxme,
     &                    (isurf(k,j),isurf(k,j)/icsurf(k,j),
     &                     k=nangles,1,-1)
1965        format(f11.3,1x,f10.5,1x,1pe12.5,2x,
     &             30(2(1x,1pe12.5)))
!     &             20(1x,1pe12.5,1x,0pf10.5))
cc            write(46,1965) xlambda(j),prf,fluxme,y1(1)
2018        format(f11.3,1x,f10.5,1x,1pe12.5,1x,e12.5,1x,e12.5)
          endif
        endif

*
* End of wavelength loop
      enddo
      if (write_radius) close(99)
*
      call clock
      RETURN
*
  100 FORMAT(4X,I1,6X,I3)
  207 FORMAT(' SPECTRUM CALCULATED FOR THE FOLLOWING ',I3,' LINES'
     &      /' ELEMENT LAMBDA XI(EV) LOG(GF) LOG(ABUND) LINE NO')
  208 FORMAT('   ',A2,I2,F9.2,F5.2,1X,F6.2,3X,F7.2,4X,I5)
  200 FORMAT(' INTENSITY SPECTRUM AT MU=',F6.2,' BETWEEN',F10.3,
     &      ' AND',F10.3,' A WITH STEP',F6.3,' A')
  201 FORMAT(' FLUX SPECTRUM BETWEEN',F10.3,' A AND ',F10.3,' A WITH',
     &       ' STEP',F6.3,' A')
  202 FORMAT(' ***WEAK LINE APPROX FOR L/KAPPA L.T.',F7.4)
  203 FORMAT(' MODEL ATMOSPHERE:',A)
  204 FORMAT(' CONTINUUM FLUX=',E12.4, ' AT ',f10.2,'AA')
  205 FORMAT(' CONTINUUM INTENSITY=',E12.4)
  206 FORMAT(1X,10F8.4)
*
      END
